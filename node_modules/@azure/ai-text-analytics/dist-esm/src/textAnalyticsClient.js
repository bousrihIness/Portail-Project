// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter, __rest } from "tslib";
import { createPipelineFromOptions, isTokenCredential, bearerTokenAuthenticationPolicy, operationOptionsToRequestOptionsBase, RestError } from "@azure/core-http";
import { SDK_VERSION } from "./constants";
import { GeneratedClient } from "./generated/generatedClient";
import { logger } from "./logger";
import { makeDetectLanguageResultArray } from "./detectLanguageResultArray";
import { makeRecognizeCategorizedEntitiesResultArray } from "./recognizeCategorizedEntitiesResultArray";
import { makeAnalyzeSentimentResultArray } from "./analyzeSentimentResultArray";
import { makeExtractKeyPhrasesResultArray } from "./extractKeyPhrasesResultArray";
import { makeRecognizeLinkedEntitiesResultArray } from "./recognizeLinkedEntitiesResultArray";
import { createSpan } from "./tracing";
import { CanonicalCode } from "@opentelemetry/api";
import { createTextAnalyticsAzureKeyCredentialPolicy } from "./azureKeyCredentialPolicy";
const DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
/**
 * Client class for interacting with Azure Text Analytics.
 */
export class TextAnalyticsClient {
    /**
     * Creates an instance of TextAnalyticsClient.
     *
     * Example usage:
     * ```ts
     * import { TextAnalyticsClient, AzureKeyCredential } from "@azure/ai-text-analytics";
     *
     * const client = new TextAnalyticsClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     * @param {string} endpointUrl The URL to the TextAnalytics endpoint
     * @param {TokenCredential | KeyCredential} credential Used to authenticate requests to the service.
     * @param {TextAnalyticsClientOptions} [options] Used to configure the TextAnalytics client.
     */
    constructor(endpointUrl, credential, options = {}) {
        this.endpointUrl = endpointUrl;
        const { defaultCountryHint = "us", defaultLanguage = "en" } = options, pipelineOptions = __rest(options, ["defaultCountryHint", "defaultLanguage"]);
        this.defaultCountryHint = defaultCountryHint;
        this.defaultLanguage = defaultLanguage;
        const libInfo = `azsdk-js-ai-textanalytics/${SDK_VERSION}`;
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        const authPolicy = isTokenCredential(credential)
            ? bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)
            : createTextAnalyticsAzureKeyCredentialPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: ["x-ms-correlation-request-id", "x-ms-request-id"]
            }
        });
        const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);
        // The contract with the generated client requires a credential, even though it is never used
        // when a pipeline is provided. Until that contract can be changed, this dummy credential will
        // throw an error if the client ever attempts to use it.
        const dummyCredential = {
            signRequest() {
                throw new Error("Internal error: Attempted to use credential from service client, but a pipeline was provided.");
            }
        };
        this.client = new GeneratedClient(dummyCredential, this.endpointUrl, pipeline);
    }
    detectLanguage(documents, countryHintOrOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const countryHint = countryHintOrOptions || this.defaultCountryHint;
                realInputs = convertToDetectLanguageInput(documents, countryHint);
                realOptions = options || {};
            }
            else {
                // Replace "none" hints with ""
                realInputs = documents.map((input) => (Object.assign(Object.assign({}, input), { countryHint: input.countryHint === "none" ? "" : input.countryHint })));
                realOptions = countryHintOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-detectLanguages", realOptions);
            try {
                const result = yield this.client.languages({
                    documents: realInputs
                }, operationOptionsToRequestOptionsBase(finalOptions));
                return makeDetectLanguageResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizeEntities(documents, languageOrOptions, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeEntities", realOptions);
            try {
                const result = yield this.client.entitiesRecognitionGeneral({
                    documents: realInputs
                }, operationOptionsToRequestOptionsBase(finalOptions));
                return makeRecognizeCategorizedEntitiesResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                let backwardCompatibleException;
                /**
                 * This special logic handles REST exception with code
                 * InvalidDocumentBatch and is needed to maintain backward compatability
                 * with sdk v5.0.0 and earlier. In general, REST exceptions are thrown as
                 * is and include both outer and inner exception codes. However, the
                 * earlier versions were throwing an exception that included the inner
                 * code only.
                 */
                const innerCode = (_d = (_c = (_b = (_a = e.response) === null || _a === void 0 ? void 0 : _a.parsedBody) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.innererror) === null || _d === void 0 ? void 0 : _d.code;
                const innerMessage = (_h = (_g = (_f = (_e = e.response) === null || _e === void 0 ? void 0 : _e.parsedBody) === null || _f === void 0 ? void 0 : _f.error) === null || _g === void 0 ? void 0 : _g.innererror) === null || _h === void 0 ? void 0 : _h.message;
                if (innerCode === "InvalidDocumentBatch") {
                    backwardCompatibleException = new RestError(innerMessage, innerCode, e.statusCode);
                }
                else {
                    backwardCompatibleException = e;
                }
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: backwardCompatibleException.message
                });
                throw backwardCompatibleException;
            }
            finally {
                span.end();
            }
        });
    }
    analyzeSentiment(documents, languageOrOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-analyzeSentiment", realOptions);
            try {
                const result = yield this.client.sentiment({
                    documents: realInputs
                }, operationOptionsToRequestOptionsBase(finalOptions));
                return makeAnalyzeSentimentResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    extractKeyPhrases(documents, languageOrOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-extractKeyPhrases", realOptions);
            try {
                const result = yield this.client.keyPhrases({
                    documents: realInputs
                }, operationOptionsToRequestOptionsBase(finalOptions));
                return makeExtractKeyPhrasesResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizeLinkedEntities(documents, languageOrOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeLinkedEntities", realOptions);
            try {
                const result = yield this.client.entitiesLinking({
                    documents: realInputs
                }, operationOptionsToRequestOptionsBase(finalOptions));
                return makeRecognizeLinkedEntitiesResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
}
function isStringArray(documents) {
    return typeof documents[0] === "string";
}
function convertToDetectLanguageInput(inputs, countryHint) {
    if (countryHint === "none") {
        countryHint = "";
    }
    return inputs.map((text, index) => {
        return {
            id: String(index),
            countryHint,
            text
        };
    });
}
function convertToTextDocumentInput(inputs, language) {
    return inputs.map((text, index) => {
        return {
            id: String(index),
            language,
            text
        };
    });
}
//# sourceMappingURL=textAnalyticsClient.js.map